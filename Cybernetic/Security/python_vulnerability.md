# Python Vulnerabilities
## Final Summary
When attempting to cast a scientific notation number to a `c_double`, the C function that is used to cast the data, `sprintf`, performs the conversion and fills the buffer provided with the string representation of the double. If the double that is being casted exceeds the buffer size it will buffer overflow. In the example identified the scientific notation number `3e300` is used which exceeds the buffer size. Further analysis I have been able to find the tipping point of `1e233`.

Using `sys.getsizeof('%.0f' % 1e233)` showed that the string size is 282 bytes but with python having some overhead this might not be accurate. 

The fix should be to use `snprintf` which will discard any extra characters when the buffer is filled and safely returning a value albiet being the wrong value.

The python function that causes this error is:
```python
from ctypes import *
c_double.from_param(1e300)
```

The C function that is called `PyCArg_repr` breaks at this line snippet:
```c
case 'd':
    sprintf(buffer, "<cparam '%c' (%f)>", self->tag, self->value.d);
    break;
```
---
## Raw Research
### CVE-2021-3177 `ctypes double representation BoF`
#### Python bugs note
- Version affected 3.6 - 3.10
- Buffer overflow is against the `PyCArg_repr()` function in `_ctypes/callproc.c`
- The buffer overflow happens when not checking the length of `sprintf()` function
```c++
case 'd':
    sprintf(buffer, "<cparam '%c' (%f)>", self->tag, self->value.d);
    break;
```
- The buffer overflow is achieved by execing the number of values 
```python
from ctypes import *
c_double.from_param(1e300)
```
- The fix is to change the `sprintf` that prints to the buffer specified regardless of its size to `snprintf`
- `snprintf` will discard any extra characters once the buffer is filled

#### About sprintf
- "ZComposes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by str"
- 
#### ZDNet notes
- The Python Software Foundation is recommending immediete upgrade to 3.9.2 and 3.8.8 to address the remote code execution
- The vulnerability affects Python 3.x through 3.9.1: A buffer overflow in `PyCArg_repr` in ctypes/callproc.c
- This overflow leads to remote execution 
- The vulnerability affects applications that "accept floating-point numbers as unstrusted input, as demonstrated by a 1e300 argument to `c_double.from_param` (zdnet)
- The bug occurs because `sprintf` is used unsafely
- The stack-based buffer overflow in python's ctypes module improperly validated the input passed to it casing the buffer overflow
- Although this is a `remote execution` buffer overflow, it may only cause DOS due to the conditions needed for the buffer overflow to be seccessful 

## Resources
[Python Bug Tracker](https://bugs.python.org/issue42938)

[ZDNet Writeup](https://www.zdnet.com/article/python-programming-language-hurries-out-update-to-tackle-remote-code-vulnerability/)

[Hex Value of 1e300](https://www.hexdictionary.com/hex/1E300)

[Sprintf function](http://www.cplusplus.com/reference/cstdio/sprintf/)

[Python Ctypes](https://docs.python.org/3/library/ctypes.html)
